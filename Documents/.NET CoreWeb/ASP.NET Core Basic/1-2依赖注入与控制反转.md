# *.NET Core ASP.NET Core* Basic 1-2
>本节内容为控制反转与依赖注入

## 简介

## 控制反转IOC
这个内容事实上在我们的C#高级篇就已经有所讲解，控制反转是一种设计模式，你可以这样理解控制反转，假设有一个人他有一部A品牌手机，他用手机进行听歌、打游戏，那么你可以创建一个手机类和一个人类

``` C#
class APhone : IPhone
{
    public string Owner{get;set;}
    public Phone(string own)
    {
        Owner = own;
    }
    void Play()
    {
        //省略
    }
    void Music()
    {
        //省略
    }
}
class Man
{
    public string Name{get;set;}
    void Game()
    {
        var p = new APhone(Name);
        p.Play();
    }
}
```
事实上这段代码的耦合度是比较高的？它使用的是正转，也就是我需要什么东西的时候我就自己创建一个这个东西。为什么说他不好呢，如果有一天这个人决定再也不使用A品牌手机了，他决定以后只使用B品牌。那么也就意味着整个的Man类使用过APhone类的地方都需要更改。这是一个非常麻烦的事情，我们这个时候就需要运用我们的IOC控制反转了。我们将实例或者是需要使用的对象的创建交给你的调用者，自己只负责使用，其它人丢给你依赖的这个过程理解为注入。

控制反转的核心就是——原本我保存使用我自己的东西，现在我把控制权交给我的上级，我需要使用的时候再向他要。这个时候，接口的作用不言而喻，A继承了Phone接口，B也继承了，假定我们一开始就使用Phone接口去创建不同的A，B对象，那么是不是可以有效的切换AB对象呢？

## 依赖注入
依赖注入体现的是一个IOC（控制反转），它非常的简单，我们之前的Man类代码中使用的是正转的方式，也就是我要一个对象，那么我就创建一个。现在我们使用依赖注入就是将我们对这个对象的控制权交给上一级接口，也就成为了这种，我想要一个对象，我就向上级发出请求，上级就给我创建了一个对象。我们通常使用构造函数注入的方式进行依赖的注入。

上文的代码就会变成
``` C#
class Man
{
    private readonly IPhone _phone;
    public Man(IPhone phone)
    {
        _phone = phone;
    }
}
```
假设这个时候你需要将手机换成B品牌，那么只需要再注入的地方传入B品牌的对象即可了。

### 容器

但是现在又出现了一个新的问题，假设说这个类有100个使用该接口的依赖，如果，我们是不是要在100个地方做这样的事情？ 控制是反转了，依赖的创建也移交到了外部。现在的问题是依赖太多，我们需要一个地方统一管理系统中所有的依赖，这个时候，我们就使用容器进行集中的管理
 
容器负责两件事情：
- 绑定服务与实例之间的关系
- 获取实例，并对实例进行管理（创建与销毁）

### 使用
说了那么多，我们如何在.NET Core中使用我们的依赖注入呢？这里我们针对的是所有的.NET Core的应用，在.NET Core中依赖注入的核心分为两个组件：位于Microsoft.Extensions.DependencyInjection命名空间下的IServiceCollection和 IServiceProvider。

其中
- IServiceCollection 负责注册
- IServiceProvider 负责提供实例






如果我的文章帮助了您，请您在github.NETCoreGuide项目帮我点一个star，在博客园中点一个关注和推荐。

>[Github](https://github.com/StevenEco/.NetCoreGuide)
>
>[BiliBili主页](https://space.bilibili.com/33311288)
>
>[WarrenRyan'sBlog](https://blog.tity.xyz)
>
>[博客园](https://cnblogs.com/warrenryan)
